/* ###################################################################
**     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
**     Filename    : CAN.c
**     Project     : HCU_V0.1
**     Processor   : MC9S08DZ60MLH
**     Component   : FreescaleCAN
**     Version     : Component 02.366, Driver 01.07, CPU db: 3.00.026
**     Compiler    : CodeWarrior HCS08 C Compiler
**     Date/Time   : 2017-05-02, 13:18, # CodeGen: 15
**     Abstract    :
**         This component "FreescaleCAN" implements a CAN serial channel.
**     Settings    :
**         CAN channel                                     : MSCAN
**
**           Interrupt service/event                       : Enabled
**             Output interrupt
**               Vector name                               : Vcantx
**               Priority                                  : 
**             Input interrupt
**               Vector name                               : Vcanrx
**               Priority                                  : 
**             Error interrupt
**               Vector name                               : Vcanerr
**               Priority                                  : 
**             Wakeup interrupt
**               Vector name                               : Vcanwu
**               Priority                                  : 
**
**          Settings                                       : 
**                Rx pin                                   : PTE7_RxD2_RXCAN
**                Rx pin signal                            : 
**                Tx pin                                   : PTE6_TxD2_TXCAN
**                Tx pin Signal                            : 
**
**
**            Recieve accept. code                         : 0x07FE4002
**            Recieve accept. mask                         : 0x0200
**            Loop Mode                                    : no
**            Bus-Off Recovery                             : Auto
**            Listen Only Mode                             : no
**            Wakeup                                       : Disabled
**
**         Protocol
**             Time segment 1                              : 3
**             Time segment 2                              : 2
**             RSJ                                         : 0
**             Samples per bit                             : One sample
**             Time quanta per bit                         : 8
**             Init baud rate                              : 250 kbit/s
**
**         Initialization
**             Enabled in init. code                       : yes
**             Events enabled in init.                     : yes
**
**         CPU clock/speed selection
**             High speed mode                             : This component enabled
**             Low speed mode                              : This component disabled
**             Slow speed mode                             : This component disabled
**
**     Contents    :
**         SetAcceptanceCode - byte CAN_SetAcceptanceCode(dword AccCode1, dword AccCode2);
**         SetAcceptanceMask - byte CAN_SetAcceptanceMask(dword AccMask1, dword AccMask2);
**         SetAcceptanceMode - byte CAN_SetAcceptanceMode(byte Mode);
**         SendFrame         - byte CAN_SendFrame(byte BufferNum, dword MessageID, byte FrameType, byte...
**         ReadFrame         - byte CAN_ReadFrame(dword *MessageID, byte *FrameType, byte *FrameFormat, byte...
**         GetStateTX        - byte CAN_GetStateTX(void);
**         GetStateRX        - bool CAN_GetStateRX(void);
**         GetError          - byte CAN_GetError(CAN_TError *Err);
**         SendFrameExt      - byte CAN_SendFrameExt(dword MessageID, byte FrameType, byte Length, byte *Data);
**
**     Copyright : 1997 - 2014 Freescale Semiconductor, Inc. 
**     All Rights Reserved.
**     
**     Redistribution and use in source and binary forms, with or without modification,
**     are permitted provided that the following conditions are met:
**     
**     o Redistributions of source code must retain the above copyright notice, this list
**       of conditions and the following disclaimer.
**     
**     o Redistributions in binary form must reproduce the above copyright notice, this
**       list of conditions and the following disclaimer in the documentation and/or
**       other materials provided with the distribution.
**     
**     o Neither the name of Freescale Semiconductor, Inc. nor the names of its
**       contributors may be used to endorse or promote products derived from this
**       software without specific prior written permission.
**     
**     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
**     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
**     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
**     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
**     ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
**     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
**     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
**     ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
**     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
**     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
**     
**     http: www.freescale.com
**     mail: support@freescale.com
** ###################################################################*/
/*!
** @file CAN.c
** @version 01.07
** @brief
**         This component "FreescaleCAN" implements a CAN serial channel.
*/         
/*!
**  @addtogroup CAN_module CAN module documentation
**  @{
*/         

/* MODULE CAN. */

#include "CAN.h"
#include "WDog_1S.h"
#include "ADCH.h"
#include "SPI_DriverSS_1.h"
#include "SPI.h"
#include "SPI_DriverSS_2.h"
#include "SPI_DriverINH_1.h"
#include "SPI_DriverFault_1.h"
#include "SPI_DriverFault_2.h"
#include "SPI_DriverINH_2.h"
#include "TI_1ms.h"
#include "TI_10ms.h"
#include "Events.h"
#include "Includes.h"


#define CAN_STANDARD_FRAME_MAX_ID    0x07FF /* Max ID of the standard frame */
#define CAN_EXTENDED_FRAME_MAX_ID    0x1FFFFFFFUL /* Max ID of the extended frame */
#define CAN_EXTENDED_FRAME_MASK      0x60000000UL /* Invalid extended frame mask*/
#define CAN_MAX_DATA_LEN             0x08 /* Max number of data to be sent in one frame */
#define FULL_RX_BUF                  0x01 /* RX buffer full           */

#define MB_ID_IDE                    0x00080000UL
#define CAN_TX_MBUFFERS              0x03 /* Number of TX buffers */
#define CAN_MAX_RX_FIFO              0x04 /* Max length of the RX fifo */

#define CAN_STATUS_OVERRUN_MASK      0x02 /* Overrun error flag mask */
#define CAN_STATUS_TX_MASK           0x0C /* Transmitter error state mask*/
#define CAN_STATUS_RX_MASK           0x30 /* Receiver error state mask*/
#define CAN_STATUS_BOFF_MASK         0x0C /* Bus-Off state mask in register */
#define CAN_STATUS_BOFF_EXT_MASK     0x40 /* Bus-Off state mask in error flag */
#define CAN_STATUS_TX_PASS_MASK      0x08 /* Transmitter error passive state mask */
#define CAN_STATUS_RX_PASS_MASK      0x20 /* Receiver error passive state mask */
#define CAN_STATUS_TX_WARN_MASK      0x04 /* Transmitter warning mask */
#define CAN_STATUS_RX_WARN_MASK      0x10 /* Receiver warning mask */
#define CAN_STATUS_WAKEUP_MASK       0x80 /* Wakeup interrupt flag mask */

typedef struct {                       /* Message buffer structure */
          byte IDR0;
          byte IDR1;
          byte IDR2;
          byte IDR3;
          byte Data[CAN_MAX_DATA_LEN];
          byte DLR;
          byte TBPR;
          byte Reserved;
          byte Reserved2;
        }TMsgBuff;                     /* Message buffer structure */

typedef union {
          dword dw;
          struct {
            byte b0;
            byte b1;
            byte b2;
            byte b3;
          }b;
        }DwordSwap;

static volatile byte ErrFlag;          /* Error flags mirror of the status register */
static volatile byte SerFlag;          /* Internal driver flags */

/*
** ===================================================================
**     Method      :  CAN_SetAcceptanceMode (component FreescaleCAN)
**     Description :
**         Sets the acceptance mode register.
**     Parameters  :
**         NAME            - DESCRIPTION
**         Mode            - Acceptance mode.
**                           Supported modes: 
**                           TWO_32_FILTERS - Two 32-bit acceptance
**                           filters
**                           FOUR_16_FILTERS - Four 16-bit acceptance
**                           filters
**                           EIGHT_8_FILTERS - Eight 8-bit acceptance
**                           filters
**                           FILTER_CLOSED - Filter closed
**     Returns     :
**         ---             - Error code, possible codes:
**                           ERR_OK - OK
**                           ERR_SPEED - This device does not work in
**                           the active speed mode
**                           ERR_DISABLED - This component is disabled
**                           by user
**                           ERR_VALUE - Parameter has incorrect value
** ===================================================================
*/
byte CAN_SetAcceptanceMode(byte Mode)
{
  if (Mode > 0x03) {                   /* Is mode parameter greater then 3 */
    return ERR_VALUE;                  /* If yes then error */
  }
  EnterCritical();                     /* Enter critical section */
  CANCTL0_INITRQ = 0x01;               /* Disable device */
  while(!CANCTL1_INITAK){}             /* Wait for disable */
  CANIDAC_IDAM = Mode;                 /* Set acceptance mode of the receiver */
  CANCTL0_INITRQ = 0x00;               /* Start device */
  while(CANCTL1_INITAK){}              /* Wait for enable */
  /* CANRFLG: WUPIF=1,CSCIF=1,RSTAT1=1,RSTAT0=1,TSTAT1=1,TSTAT0=1,OVRIF=1 */
  CANRFLG |= 0xFE;                     /* Reset error flags */
  /* CANRIER: WUPIE=0,CSCIE=1,RSTATE1=1,RSTATE0=1,TSTATE1=1,TSTATE0=1,OVRIE=0,RXFIE=1 */
  CANRIER = 0x7D;                      /* Enable interrupts */
  ExitCritical();                      /* Exit critical section */
  return ERR_OK;                       /* OK */
}

/*
** ===================================================================
**     Method      :  CAN_GetStateRX (component FreescaleCAN)
**     Description :
**         Returns a value of the reception complete flag.
**     Parameters  : None
**     Returns     :
**         ---             - The value of the receiver complete flag of
**                           the given buffer. Possible values: <false>
**                           - message buffer is empty <true> - message
**                           buffer isn't empty
** ===================================================================
*/
byte CAN_GetStateRX(void)
{
  return (byte)(((SerFlag & FULL_RX_BUF) != 0x00)? (byte)1 : (byte)0); /* Return status of the RX buffer */
}

/*
** ===================================================================
**     Method      :  CAN_SetAcceptanceCode (component FreescaleCAN)
**     Description :
**         Sets the acceptance code registers. This method writes a
**         code mask directly to the acceptance code registers.
**     Parameters  :
**         NAME            - DESCRIPTION
**         AccCode1        - Acceptance code for the message
**                           filtering. This acceptance code will be
**                           written to the acceptance code registers
**                           IDAR0-IDAR3. The most significant byte of
**                           the acceptance code will be written to the
**                           IDAR0 register and the least significant
**                           byte of the acceptance code will be written
**                           to the IDAR3 register.
**         AccCode2        - Acceptance code for the message
**                           filtering. This acceptance code will be
**                           written to the acceptance code registers
**                           IDAR4-IDAR7. The most significant byte of
**                           the acceptance code will be written to the
**                           IDAR4 register and the least significant
**                           byte of the acceptance code will be written
**                           to the IDAR7 register.
**     Returns     :
**         ---             - Error code, possible codes:
**                           ERR_OK - OK
**                           ERR_SPEED - This device does not work in
**                           the active speed mode
**                           ERR_DISABLED - This component is disabled
**                           by user
** ===================================================================
*/
byte CAN_SetAcceptanceCode(dword AccCode1, dword AccCode2)
{
  EnterCritical();                     /* Enter critical section */
  CANCTL0_INITRQ = 0x01;               /* Disable device */
  while(!CANCTL1_INITAK){}             /* Wait for disable */
  CANIDAR3 = ((DwordSwap *)&AccCode1)->b.b3; /* Set acceptance code, register CANIDAR3 */
  CANIDAR2 = ((DwordSwap *)&AccCode1)->b.b2; /* Set acceptance code, register CANIDAR2 */
  CANIDAR1 = ((DwordSwap *)&AccCode1)->b.b1; /* Set acceptance code, register CANIDAR1 */
  CANIDAR0 = ((DwordSwap *)&AccCode1)->b.b0; /* Set acceptance code, register CANIDAR0 */
  CANIDAR7 = ((DwordSwap *)&AccCode2)->b.b3; /* Set acceptance code, register CANIDAR7 */
  CANIDAR6 = ((DwordSwap *)&AccCode2)->b.b2; /* Set acceptance code, register CANIDAR6 */
  CANIDAR5 = ((DwordSwap *)&AccCode2)->b.b1; /* Set acceptance code, register CANIDAR5 */
  CANIDAR4 = ((DwordSwap *)&AccCode2)->b.b0; /* Set acceptance code, register CANIDAR4 */
  CANCTL0_INITRQ = 0x00;               /* Start device */
  while(CANCTL1_INITAK){}              /* Wait for enable */
  /* CANRFLG: WUPIF=1,CSCIF=1,RSTAT1=1,RSTAT0=1,TSTAT1=1,TSTAT0=1,OVRIF=1 */
  CANRFLG |= 0xFE;                     /* Reset error flags */
  /* CANRIER: WUPIE=0,CSCIE=1,RSTATE1=1,RSTATE0=1,TSTATE1=1,TSTATE0=1,OVRIE=0,RXFIE=1 */
  CANRIER = 0x7D;                      /* Enable interrupts */
  ExitCritical();                      /* Exit critical section */
  return ERR_OK;                       /* OK */
}

/*
** ===================================================================
**     Method      :  CAN_GetError (component FreescaleCAN)
**     Description :
**         Returns the content of the receiver flag register.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * Err             - Pointer to the returned set of errors
**     Returns     :
**         ---             - Error code (if GetError did not succeed),
**                           possible codes:
**                           ERR_OK - OK
**                           ERR_SPEED - This device does not work in
**                           the active speed mode
** ===================================================================
*/
byte CAN_GetError(CAN_TError *Err)
{
  Err->err = 0x00;                     /* Clear all errors */
  Err->errName.BusOff = ((ErrFlag & CAN_STATUS_BOFF_EXT_MASK) == CAN_STATUS_BOFF_EXT_MASK); /* Bus-Off state */
  Err->errName.TxWarning = ((ErrFlag & CAN_STATUS_TX_WARN_MASK) == CAN_STATUS_TX_WARN_MASK); /* Transmitter warning */
  Err->errName.RxWarning = ((ErrFlag & CAN_STATUS_RX_WARN_MASK) == CAN_STATUS_RX_WARN_MASK); /* Receiver warning */
  Err->errName.RxPassive = ((ErrFlag & CAN_STATUS_RX_PASS_MASK) == CAN_STATUS_RX_PASS_MASK); /* Receiver Error passive state */
  Err->errName.TxPassive = ((ErrFlag & CAN_STATUS_TX_PASS_MASK) == CAN_STATUS_TX_PASS_MASK); /* Transmitter Error passive state */
  Err->errName.OverRun = ((ErrFlag & CAN_STATUS_OVERRUN_MASK) == CAN_STATUS_OVERRUN_MASK); /* Overrun error flag */
  ErrFlag = 0x00;                      /* Clear error flags */
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  CAN_SendFrame (component FreescaleCAN)
**     Description :
**         Sends the frame via the CAN device. Using this method the
**         user can send own message to the CAN bus. This method allows
**         to specify CAN buffer number, message ID, data to be sent
**         and frame type (DATA_FRAME/REMOTE_FRAME).
**     Parameters  :
**         NAME            - DESCRIPTION
**         BufferNum       - Number of the buffer.
**         MessageID       - Identification of the message
**                           - ID. Message ID can be specified in the
**                           STANDARD format (default) or the EXTENDED
**                           format. The most significant bit in the ID
**                           is set to specify EXTENDED format.
**                           Predefined macro CAN_EXTENDED_FRAME_ID can
**                           be used (ID "bitwise or"
**                           CAN_EXTENDED_FRAME_ID) to mark ID as
**                           extended. If the most significant bit of ID
**                           is clear, STANDARD format is used.
**         FrameType       - Type of frame
**                           DATA_FRAME - data frame
**                           REMOTE_FRAME - remote frame
**         Length          - The length of the frame in bytes (0..
**                           8)
**       * Data            - Pointer to data
**     Returns     :
**         ---             - Error code, possible codes:
**                           ERR_OK - OK
**                           ERR_SPEED - This device does not work in
**                           the active speed mode
**                           ERR_DISABLED - This component is disabled
**                           by user
**                           ERR_VALUE - Some parameter is out of
**                           possible range
**                           ERR_TXFULL - Transmition buffer is full.
** ===================================================================
*/
byte CAN_SendFrame(byte BufferNum,dword MessageID,byte FrameType,byte Length,byte *Data)
{
  byte i;                              /* Temporary variables */
  byte bufmask = (byte)(1U << BufferNum); /* Buffer mask */
  TMsgBuff *MsgBuff;
  dword tmpId;

  if (((MessageID & CAN_EXTENDED_FRAME_ID) == 0) && (MessageID > CAN_STANDARD_FRAME_MAX_ID)) { /* Is the standard ID greater that 2047? */
    return ERR_VALUE;                  /* If yes then error */
  }
  if (((MessageID & CAN_EXTENDED_FRAME_ID) == CAN_EXTENDED_FRAME_ID) && (MessageID & CAN_EXTENDED_FRAME_MASK)) { /* Is the extended ID greater that 536870911? */
    return ERR_VALUE;                  /* If yes then error */
  }
  if ((BufferNum > (CAN_TX_MBUFFERS - 1)) || (Length > CAN_MAX_DATA_LEN)) { /* Is BufferNum greater than CAN_MAXBUFF or Length greater than CAN_MAX_DATA_LEN? */
    return ERR_VALUE;                  /* If yes then error */
  }
  if (FrameType > REMOTE_FRAME) {      /* Is FrameType other than REMOTE_FRAME or DATA_FRAME */
    return ERR_VALUE;                  /* If yes then error */
  }
  EnterCritical();                     /* Disable global interrupts */
  if (!(CANTFLG & bufmask)) {          /* Is the transmit buffer full? */
    ExitCritical();                    /* Enable global interrupts */
    return ERR_TXFULL;                 /* If yes then error */
  }
  CANTBSEL = bufmask;                  /* Select requested transmit buffer */
  MsgBuff = (TMsgBuff *)&CANTIDR0;
  CANTIER_TXEIE |= bufmask;            /* Enable transmit interrupt of the given buffer */
  if (MessageID & CAN_EXTENDED_FRAME_ID) {
    tmpId = (((MessageID & 0x1FFC0000UL) << 3) | 0x00180000UL | ((MessageID & 0x0003FFFFUL) << 1)); /* Extended frame */
  }
  else {
    tmpId = MessageID << 21;           /* Standard frame */
  }
  MsgBuff->IDR3 = ((DwordSwap *)&tmpId)->b.b3; /* Store the message ID */
  MsgBuff->IDR2 = ((DwordSwap *)&tmpId)->b.b2;
  MsgBuff->IDR1 = ((DwordSwap *)&tmpId)->b.b1;
  MsgBuff->IDR0 = ((DwordSwap *)&tmpId)->b.b0;
  if (FrameType == DATA_FRAME) {       /* Is it a data frame? */
    for (i=0; i<Length; i++) {
      MsgBuff->Data[i] = Data[i];      /* Store data to the transmit register */
    }
    if (MessageID & CAN_EXTENDED_FRAME_ID) { /* Is it the extended frame? */
      MsgBuff->IDR3 &= 0xFE;           /* If no then set message type as "data frame" */
    }
    else {
      MsgBuff->IDR1 &= 0xEF;           /* If yes then set message type as "data frame" */
    }
  }
  else {                               /* Remote frame */
    if (MessageID & CAN_EXTENDED_FRAME_ID) { /* Is it the extended frame? */
      MsgBuff->IDR3 |= 0x01;           /* If yes then set message type as "remote frame" */
    }
    else {
      MsgBuff->IDR1 |= 0x10;           /* If yes then set message type as "remote frame" */
    }
  }
  MsgBuff->DLR = Length;               /* Set the length of the message */
  CANTFLG = bufmask;                   /* Start transmission */
  ExitCritical();                      /* Enable global interrupts */
  return ERR_OK;                       /* OK */
}

/*
** ===================================================================
**     Method      :  CAN_SendFrameExt (component FreescaleCAN)
**     Description :
**         Sends a frame. This method automatically selects a free
**         transmit buffer for data transmission. The user cannot
**         specify a transmit buffer.
**     Parameters  :
**         NAME            - DESCRIPTION
**         MessageID       - Identification of the message
**                           - ID. Message ID can be specified in the
**                           STANDARD format (default) or the EXTENDED
**                           format. The most significant bit in the ID
**                           is set to specify EXTENDED format.
**                           Predefined macro CAN_EXTENDED_FRAME_ID can
**                           be used (ID "bitwise or"
**                           CAN_EXTENDED_FRAME_ID) to mark ID as
**                           extended. If the most significant bit of ID
**                           is clear, STANDARD format is used.
**         FrameType       - Type of frame
**                           DATA_FRAME - data frame
**                           REMOTE_FRAME - remote frame
**         Length          - The length of the frame in bytes (0..
**                           8)
**       * Data            - Pointer to data
**     Returns     :
**         ---             - Error code, possible codes:
**                           ERR_OK - OK
**                           ERR_SPEED - This device does not work in
**                           the active speed mode
**                           ERR_DISABLED - This component is disabled
**                           by user
**                           ERR_VALUE - Some parameter is out of
**                           possible range
** ===================================================================
*/
byte CAN_SendFrameExt(dword MessageID,byte FrameType,byte Length,byte *Data)
{
  byte i;                              /* Temporary variables */
  TMsgBuff *MsgBuff;
  dword tmpId;

  if (((MessageID & CAN_EXTENDED_FRAME_ID) == 0) && (MessageID > CAN_STANDARD_FRAME_MAX_ID)) { /* Is the standard ID greater that 2047? */
    return ERR_VALUE;                  /* If yes then error */
  }
  if (((MessageID & CAN_EXTENDED_FRAME_ID) == CAN_EXTENDED_FRAME_ID) && (MessageID & CAN_EXTENDED_FRAME_MASK)) { /* Is the extended ID greater that 536870911? */
    return ERR_VALUE;                  /* If yes then error */
  }
  if (Length > CAN_MAX_DATA_LEN) {     /* Is the message length greater than 8?*/
    return ERR_VALUE;                  /* If yes then error */
  }
  if (FrameType > REMOTE_FRAME) {      /* Is FrameType other than REMOTE_FRAME or DATA_FRAME */
    return ERR_VALUE;                  /* If yes then error */
  }
  EnterCritical();                     /* Disable global interrupts */
  if (!(CANTFLG & 0x07)) {             /* Are all transmit buffers full? */
    ExitCritical();                    /* Enable global interrupts */
    return ERR_TXFULL;                 /* If yes then error */
  }
  CANTBSEL = CANTFLG;                  /* Find any empty transmit buffer */
  MsgBuff = (TMsgBuff *)&CANTIDR0;
  CANTIER_TXEIE = CANTBSEL;            /* Enable transmit of the selected TX buffer */
  if (MessageID & CAN_EXTENDED_FRAME_ID) {
    tmpId = (((MessageID & 0x1FFC0000UL) << 3) | 0x00180000UL | ((MessageID & 0x0003FFFFUL) << 1)); /* Extended frame */
  }
  else {
    tmpId = MessageID << 21;           /* Standard frame */
  }
  MsgBuff->IDR3 = ((DwordSwap *)&tmpId)->b.b3; /* Store the message ID */
  MsgBuff->IDR2 = ((DwordSwap *)&tmpId)->b.b2;
  MsgBuff->IDR1 = ((DwordSwap *)&tmpId)->b.b1;
  MsgBuff->IDR0 = ((DwordSwap *)&tmpId)->b.b0;
  if (FrameType == DATA_FRAME) {       /* Is it a data frame? */
    for (i=0; i<Length; i++) {
      MsgBuff->Data[i] = Data[i];      /* Store data to the transmit register */
    }
    if (MessageID & CAN_EXTENDED_FRAME_ID) { /* Is it the extended frame? */
      MsgBuff->IDR3 &= 0xFE;           /* If no then set message type as "data frame" */
    }
    else {
      MsgBuff->IDR1 &= 0xEF;           /* If yes then set message type as "data frame" */
    }
  }
  else {                               /* Remote frame */
    if (MessageID & CAN_EXTENDED_FRAME_ID) { /* Is it the extended frame? */
      MsgBuff->IDR3 |= 0x01;           /* If yes then set message type as "remote frame" */
    }
    else {
      MsgBuff->IDR1 |= 0x10;           /* If yes then set message type as "remote frame" */
    }
  }
  CANTDLR = Length;                    /* Set the length of the message */
  CANTFLG = CANTBSEL;                  /* Start transmission */
  ExitCritical();                      /* Enable global interrupts */
  return ERR_OK;                       /* OK */
}

/*
** ===================================================================
**     Method      :  CAN_ReadFrame (component FreescaleCAN)
**     Description :
**         Reads a frame from the CAN device. The user is informed
**         about CAN reception through OnFullRxBuffer event or
**         GetStateRX method.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * MessageID       - Pointer to a message
**                           indentification
**       * FrameType       - Pointer to a frame type
**                           DATA_FRAME - data frame
**                           REMOTE_FRAME - remote frame
**       * FrameFormat     - Pointer to a frame format
**                           STANDARD_FORMAT - standard frame 11-bits
**                           EXTENDED_FORMAT - extended frame 29-bits.
**                           Note: This parameter is obsolete and will
**                           be removed in future releases.
**       * Length          - Pointer to a length of the frame
**       * Data            - The buffer for received data
**     Returns     :
**         ---             - Error code, possible codes:
**                           ERR_OK - OK
**                           ERR_SPEED - This device does not work in
**                           the active speed mode
**                           ERR_DISABLED - This component is disabled
**                           by user
**                           ERR_RXEMPTY - The receive buffer is empty
**                           ERR_OVERRUN - The previous (unread) message
**                           in the receive buffer was overwriten by a
**                           new message. Returns only if Interrupt
**                           service is enabled.
** ===================================================================
*/
byte CAN_ReadFrame(dword *MessageID,byte *FrameType,byte *FrameFormat,byte *Length,byte *Data)
{
  byte i;
  dword tmpId = 0;

  if (!(SerFlag & FULL_RX_BUF)) {      /* Is the receive buffer empty? */
    return ERR_RXEMPTY;                /* If yes then error */
  }
  ((DwordSwap*)&tmpId)->b.b0 = CANRIDR0;
  ((DwordSwap*)&tmpId)->b.b1 = CANRIDR1;
  ((DwordSwap*)&tmpId)->b.b2 = CANRIDR2;
  ((DwordSwap*)&tmpId)->b.b3 = CANRIDR3;
  if (tmpId & MB_ID_IDE) {
    *MessageID = ((tmpId >> 1) & 0x3FFFFUL) | ((tmpId >> 3) & 0x1FFC0000UL) | CAN_EXTENDED_FRAME_ID; /* Extended frame */
  }
  else {
    *MessageID = tmpId >> 21;          /* Standard frame */
  }
  if (*MessageID & CAN_EXTENDED_FRAME_ID) {
    *FrameFormat = EXTENDED_FORMAT;
    *FrameType = (byte)((CANRIDR3 & 0x01)? (byte)REMOTE_FRAME : (byte)DATA_FRAME); /* Result the frame type */
    *MessageID &= ~CAN_EXTENDED_FRAME_ID; /* Remove EXTENDED_FRAME indicator, frame type will be returned in FrameType parameter */
  }
  else {
    *FrameFormat = STANDARD_FORMAT;
    *FrameType = (byte)((CANRIDR1 & 0x10)? (byte)REMOTE_FRAME : (byte)DATA_FRAME); /* Result the frame type */
  }
  *Length = (byte)(CANRDLR & 0x0F);    /* Result length of the message */
  if (*FrameType == DATA_FRAME) {      /* Is it "data frame"? */
    for (i=0; i<*Length; i++) {
      Data[i] = *((byte *)&CANRDSR0 + i); /* Return received data */
    }
  }
  SerFlag &= ~FULL_RX_BUF;             /* Clear flag "full RX buffer" */
  if (SerFlag & CANRFLG_OVRIF_MASK) {  /* Is the overrun detected? */
    SerFlag &= ~CANRFLG_OVRIF_MASK;    /* Clear the internal overrun flag */
    return ERR_OVERRUN;                /* If yes then error */
  }
  return ERR_OK;                       /* OK */
}

/*
** ===================================================================
**     Method      :  CAN_Init (component FreescaleCAN)
**
**     Description :
**         Initializes the associated peripheral(s) and the components 
**         internal variables. The method is called automatically as a 
**         part of the application initialization code.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
void CAN_Init(void)
{
  /* CANCTL1: CANE=1,CLKSRC=0,LOOPB=0,LISTEN=0,BORM=0,WUPM=0,SLPAK=0,INITAK=0 */
  CANCTL1 = 0x80;                      /* Set the control register */
  /* CANCTL0: RXFRM=0,RXACT=0,CSWAI=0,SYNCH=0,TIME=0,WUPE=0,SLPRQ=0,INITRQ=1 */
  CANCTL0 = 0x01;                      /* Set the control register */
  CANIDAC_IDAM = 0x00;                 /* Set the acceptance mode */
  CANIDAR0 = 0x07;                     /* Set the acceptance code, register CANIDAR0 */
  CANIDAR1 = 0xFE;                     /* Set the acceptance code, register CANIDAR1 */
  CANIDAR2 = 0x40;                     /* Set the acceptance code, register CANIDAR2 */
  CANIDAR3 = 0x02;                     /* Set the acceptance code, register CANIDAR3 */
  CANIDAR4 = 0x00;                     /* Set the acceptance code, register CANIDAR4 */
  CANIDAR5 = 0x00;                     /* Set the acceptance code, register CANIDAR5 */
  CANIDAR6 = 0x00;                     /* Set the acceptance code, register CANIDAR6 */
  CANIDAR7 = 0x00;                     /* Set the acceptance code, register CANIDAR7 */
  CANIDMR0 = 0x00;                     /* Set the acceptance mask, register CANIDMR0 */
  CANIDMR1 = 0x00;                     /* Set the acceptance mask, register CANIDMR1 */
  CANIDMR2 = 0x02;                     /* Set the acceptance mask, register CANIDMR2 */
  CANIDMR3 = 0x00;                     /* Set the acceptance mask, register CANIDMR3 */
  CANIDMR4 = 0x00;                     /* Set the acceptance mask, register CANIDMR4 */
  CANIDMR5 = 0x00;                     /* Set the acceptance mask, register CANIDMR5 */
  CANIDMR6 = 0x00;                     /* Set the acceptance mask, register CANIDMR6 */
  CANIDMR7 = 0x00;                     /* Set the acceptance mask, register CANIDMR7 */
  /* CANBTR0: SJW1=0,SJW0=0,BRP5=0,BRP4=0,BRP3=0,BRP2=1,BRP1=1,BRP0=1 */
  CANBTR0 = 0x07;                      /* Set the device timing register */
  /* CANBTR1: SAMP=0,TSEG22=0,TSEG21=1,TSEG20=0,TSEG13=0,TSEG12=0,TSEG11=1,TSEG10=1 */
  CANBTR1 = 0x23;                      /* Set the device timing register */
  CANCTL1_CLKSRC = 0x01;               /* Select the clock source from bus clock */
  CANCTL0_INITRQ = 0x00;               /* Start device */
  while(CANCTL1_INITAK) {}             /* Wait for enable */
  /* CANRFLG: WUPIF=1,CSCIF=1,RSTAT1=1,RSTAT0=1,TSTAT1=1,TSTAT0=1,OVRIF=1 */
  CANRFLG |= 0xFE;                     /* Reset error flags */
  /* CANRIER: WUPIE=0,CSCIE=1,RSTATE1=1,RSTATE0=1,TSTATE1=1,TSTATE0=1,OVRIE=0,RXFIE=1 */
  CANRIER = 0x7D;                      /* Enable interrupts */
}

/*
** ===================================================================
**     Method      :  CAN_GetStateTX (component FreescaleCAN)
**     Description :
**         Returns a value of the transmission complete flags.
**     Parameters  : None
**     Returns     :
**         ---             - Content of the transmitter complete flag
**                           register.
** ===================================================================
*/
/*
byte CAN_GetStateTX(void)

**      This method is implemented as a macro in the header module. **
*/

/*
** ===================================================================
**     Method      :  CAN_SetAcceptanceMask (component FreescaleCAN)
**     Description :
**         Sets the acceptance mask registers. This method writes an
**         acceptance mask directly to the acceptance mask registers.
**     Parameters  :
**         NAME            - DESCRIPTION
**         AccMask1        - Acceptance mask for the message
**                           filtering. This acceptance mask will be
**                           written to the acceptance mask registers
**                           IDMR0-IDMR3. The most significant byte of
**                           the acceptance mask will be written to the
**                           IDMR0 register and the least significant
**                           byte of the acceptance mask will be written
**                           to the IDMR3 register.
**         AccMask2        - Acceptance mask for the message
**                           filtering. This acceptance mask will be
**                           written to the acceptance mask registers
**                           IDMR4-IDMR7. The most significant byte of
**                           the acceptance mask will be written to the
**                           IDMR4 register and the least significant
**                           byte of the acceptance mask will be written
**                           to the IDMR7 register.
**     Returns     :
**         ---             - Error code, possible codes:
**                           ERR_OK - OK
**                           ERR_SPEED - This device does not work in
**                           the active speed mode
**                           ERR_DISABLED - This component is disabled
**                           by user
** ===================================================================
*/
byte CAN_SetAcceptanceMask(dword AccMask1, dword AccMask2)
{
  EnterCritical();                     /* Enter critical section */
  CANCTL0_INITRQ = 0x01;               /* Disable device */
  while(!CANCTL1_INITAK){}             /* Wait for disable */
  CANIDMR3 = ((DwordSwap *)&AccMask1)->b.b3; /* Set acceptance mask, register CANIDMR3 */
  CANIDMR2 = ((DwordSwap *)&AccMask1)->b.b2; /* Set acceptance mask, register CANIDMR2 */
  CANIDMR1 = ((DwordSwap *)&AccMask1)->b.b1; /* Set acceptance mask, register CANIDMR1 */
  CANIDMR0 = ((DwordSwap *)&AccMask1)->b.b0; /* Set acceptance mask, register CANIDMR0 */
  CANIDMR7 = ((DwordSwap *)&AccMask2)->b.b3; /* Set acceptance mask, register CANIDMR7 */
  CANIDMR6 = ((DwordSwap *)&AccMask2)->b.b2; /* Set acceptance mask, register CANIDMR6 */
  CANIDMR5 = ((DwordSwap *)&AccMask2)->b.b1; /* Set acceptance mask, register CANIDMR5 */
  CANIDMR4 = ((DwordSwap *)&AccMask2)->b.b0; /* Set acceptance mask, register CANIDMR4 */
  CANCTL0_INITRQ = 0x00;               /* Start device */
  while(CANCTL1_INITAK) {}             /* Wait for device initialization acknowledge */
  /* CANRFLG: WUPIF=1,CSCIF=1,OVRIF=1 */
  CANRFLG |= 0xC2;                     /* Reset error flags */
  /* CANRIER: WUPIE=0,CSCIE=1,RSTATE1=1,RSTATE0=1,TSTATE1=1,TSTATE0=1,OVRIE=0,RXFIE=1 */
  CANRIER = 0x7D;                      /* Enable interrupts */
  ExitCritical();                      /* Exit critical section */
  return ERR_OK;                       /* OK */
}


/*
** ===================================================================
**     Method      :  CAN_InterruptTx (component FreescaleCAN)
**
**     Description :
**         The method services the transmit interrupt of the selected 
**         peripheral(s) and eventually invokes the components event(s).
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
ISR(CAN_InterruptTx)
{
  byte buffer = (byte)((CANTFLG & CANTIER) & 7); /* Temporary variable */

  CANTIER &= ~buffer;                  /* Clear appropriate transmit flags and release TX buffer */
  CAN_OnFreeTxBuffer((word)buffer);    /* If yes then invoke user event */
}

/*
** ===================================================================
**     Method      :  CAN_InterruptRx (component FreescaleCAN)
**
**     Description :
**         The method services the receive interrupt of the selected 
**         peripheral(s) and eventually invokes the components event(s).
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
#define ON_OVERRUN  1
ISR(CAN_InterruptRx)
{
  if (SerFlag & FULL_RX_BUF) {         /* Is any char already present in the receive buffer? */
    SerFlag |= CAN_STATUS_OVERRUN_MASK; /* If yes then set internal flag OVERRUN */
  }
  SerFlag |= FULL_RX_BUF;              /* Set flag "full RX buffer" */
  ErrFlag |= (SerFlag & 0x83);         /* Add new error flags into the ErrorFlag status variable */
  CAN_OnFullRxBuffer();                /* If yes then invoke user event */
  CANRFLG = CANRFLG_RXF_MASK;          /* Reset the reception complete flag and release the RX buffer */
}

/*
** ===================================================================
**     Method      :  CAN_InterruptError (component FreescaleCAN)
**
**     Description :
**         The method services the error interrupt of the selected 
**         peripheral(s) and eventually invokes the components event(s).
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
ISR(CAN_InterruptError)
{
  byte Status = CANRFLG;               /* Read the status register */

  if((Status & CAN_STATUS_BOFF_MASK) == CAN_STATUS_BOFF_MASK) { /* Bus-Off state */
    ErrFlag |= CAN_STATUS_BOFF_EXT_MASK;
    ErrFlag |= (Status & 0x83);        /* Add error flags */
  }
  else {
    ErrFlag |= (Status & 0xBF);        /* Add error flags */
  }
  CANRFLG = 0xFE;                      /* Reset error flags */
  if ((Status & CAN_STATUS_BOFF_MASK) == CAN_STATUS_BOFF_MASK) { /* Is busoff error detected? */
    CAN_OnBusOff();                    /* If yes then invoke user event */
  } else {
  }
}


/* END CAN. */
/*!
** @}
*/
/*
** ###################################################################
**
**     This file was created by Processor Expert 10.3 [05.09]
**     for the Freescale HCS08 series of microcontrollers.
**
** ###################################################################
*/
